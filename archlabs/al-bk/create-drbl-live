#!/bin/bash
# Author: Steven Shiau <steven _at_ nchc org tw>
# License: GPL
# Description: This script will create a DRBL live CD/USB flash drive iso/zip

#
set -e

#
DRBL_SCRIPT_PATH="${DRBL_SCRIPT_PATH:-/usr/share/drbl}"

. $DRBL_SCRIPT_PATH/sbin/drbl-conf-functions
. /etc/drbl/drbl-ocs.conf
. $DRBL_SCRIPT_PATH/sbin/ocs-functions

# debian_mirror_url_def, debian_mirror_security_url_def, DRBL_REPOSITORY_URL_def and DRBL_GPG_KEY_URL are loaded from drbl-ocs.conf

debian_type="minbase"
#debian_type="standard"
DEBIAN_DIST_DEF="sid"
pkgs="$PKG_FROM_DBN_WHICH_OCS_LIVE_NEED drbl $PKG_FROM_DBN $PKG_FROM_DRBL"
categories_default="main"
cpu_flavor_default="586"
bootstrap_default="debootstrap"

# The files in dir $ocs_live_script_dir/ will be copied to the dir live-hook-dir in dir chroot. The file "drbl-live-hook" is in $ocs_live_script_dir
ocs_live_script_dir="$DRBL_SCRIPT_PATH/setup/files/ocs/live-hook"
# The script inside $ocs_live_script_dir/ will be run when chroot. There are many files in $$ocs_live_script_dir/, we will just run one here.
run_hook_script="drbl-live-hook"
# This hook is for binary_local-hooks, not for chroot hook
run_binary_hook_script="efi-binary-hook"
# The option to create a corresponding source image.
gen_source_tarball="no"
# Flag to put EFI booting image in iso
enabled_EFI=""
# The default init system for live system
live_initsystem_def="systemd"

#
check_if_root
#
prog="$(basename $0)"
full_cmd="$prog $*"

# functions
USAGE() {
    echo "Usage:"
    echo "To create a Debian live CD which is used a template for Clonezilla live:"
    echo "$prog [OPTION]"
    echo "OPTION:"
    language_help_prompt_by_idx_no
    echo "-a, --initsystem [sysvinit|systemd]   Specify the init system for live system. Default is systemd"
    echo "-b, --branch [s|stable|t|testing|u|unstable|e|experimental]  Specify the DRBL branch to be used in Live CD. Default is stable."
    echo "-bt, --bootstrap BOOTSTRAP  Specify the bootsrap type as BOOTSTRAP (cdebootstrap or debootstrap). If not specified, $bootstrap_default will be used."
    echo "-c, --categories CAT   Sepcify the category, e.g. 'main', 'main non-free', default is \'$categories_default\' if not specified."
    echo "-d, --debian-dist [stable|testing|unstable|lenny|squeeze|wheezy|sid...]  Assign Debian dist, the default is $DEBIAN_DIST_DEF if not assigned."
    echo "-f, --arch-flavor ARCH  Assign the CPU architecture flavor as ARCH, e.g. 586 or 686. If it's not assigned, $cpu_flavor_default will be used."
    echo "-g, --drbl-repo-url URL  Assign the DRBL repository URL instead of default one $DRBL_REPOSITORY_URL_def."
    echo "-n, --live-kernel-pkg KERNEL_VER Assign kernel version as KERNEL_VER (KERNEL VER package must exist in repository. Ex. if KERNEL_VER is 2.6.20-1-486, then linux-image-2.6.20-1-486, squashfs-modules-2.6.20-1-486, and unionfs-modules-2.6.20-1-486 will be used."
    echo "-i, --assign-version-no NO  Assign the version no as NO instead of date."
    echo "-e, --drbl-live-branch [s|stable|t|testing|u|unstable|e|experimental]  specifies the DRBL live branch to be used in Live CD. Default is stable."
    echo "-k, --package FILE  Specify package FILE to be installed in Live CD."
    echo "-p, --metapackages TASK  Specifies a task metapackage maintained by your distribution (such as task-xfce-desktop,task-gnome-desktop ...), one package for each line"
    echo "-m, --mirror-url URL  Assign the Debian repository URL instead of default one $debian_mirror_url_def. "
    echo "-r, --rm-tmp-iso    Remove the first stage temp iso file"
    echo "-s, --mirror-security-url URL  Assign the Debian security repository URL instead of default one $debian_mirror_security_url_def."
    echo "-o, --create-source-tarball  Create a corresponding source image to the binary image.  By default such an source image will not be created since this would require to download quite a few source packages."
    echo "-t, --target-media-file  [cd|iso|usb|zip|b|both] Assign the target media file as CD (cd or iso), USB flash drive (usb or zip) or both of them (b or both). Default is both"
    echo "-u, --use-existing-tmp-iso  Use the existing first stage temp iso file"
    echo "-x, --extra-boot-param  EXTRA_PARAM  Assign extra boot parameter EXTRA_PARAM for the kernel to read. These parameters are the same with that from live-initramfs. Ex. \"noeject\" can be use to not prompt to eject the CD on reboot."
    echo "-y, --syslinux-ver VER  Assign the syslinux version as VER. E.g. 6.02, 6.03-pre1"
    echo "-v, --verbose    Run live build in verbose mode"
    echo "Ex: $0 -l en -d etch -p xfce -b u -k \"iceweasel-l10n-zh-tw x-ttcidfont-conf ttf-arphic-newsung gparted scim-chewing scim-tables-zh im-switch mlterm mlterm-im-scim discover1 mdetect\" -e e -n 2.6.24-etchnhalf.1 -i 0.9.11-7"
}
#
clean_tmp_dirs_files() {
  if [ -d "$stage1_iso_TMP" -a \
       -n "$(echo $stage1_iso_TMP | grep "ocs-iso-tmp")" ]; then
    rm -rf $stage1_iso_TMP
  fi
  if [ -d "$ISOSYSLNX_TMP" -a \
       -n "$(echo $ISOSYSLNX_TMP | grep "isolnx-tmp")" ]; then
    rm -rf $ISOSYSLNX_TMP
  fi
  if [ -d "$USB_TMP" -a -n "$(echo $USB_TMP | grep "ocs-usb-dev")" ]; then
    rm -rf $USB_TMP
  fi
  # clean the tmp iso.
  if [ "$rm_tmp_iso" = "yes" -a -f "$stage1_target_iso" ]; then
    rm -f $stage1_target_iso
  fi
} # end of clean_tmp_dirs_files
#
create_version_tag_in_live() {
  local tag_file_in_abs_path="$1"
  local ver_tag_="$2"
  local drbl_v clonezilla_v
  drbl_v="$(dpkg -l drbl | tail -n 1 | awk -F" " '{print $3}')"
  clonezilla_v="$(dpkg -l clonezilla | tail -n 1 | awk -F" " '{print $3}')"
  cat <<-TAG_END > $tag_file_in_abs_path
$ver_tag_
DRBL: $drbl_v
Clonezilla: $clonezilla_v
This DRBL live was created by:
$full_cmd
TAG_END
}
#
create_drbl_live_iso(){
  echo "$msg_delimiter_star_line"
  echo "Creating DRBL server iso file..."
  echo "$msg_delimiter_star_line"
  #
  # Possible kernel/initrd paths are /casper (created by casper) or /live (created by live-initramfs)
  # Find the kernel and initrd in $stage1_iso_TMP/casper or $stage1_iso_TMP/live
  # Ex: $stage1_iso_TMP/casper/vmlinuz1, /$stage1_iso_TMP/casper/initrd1.img
  # $live_sys_files_dir_list is from drbl-ocs.conf.
  # Possible kernel/initrd paths are /casper (created by casper) or /live (created by live-initramfs)
  sys_files_dir=""
  for i in $live_sys_files_dir_list; do
    krnfile="$(find $stage1_iso_TMP/$i/ -maxdepth 1 -name "vmlinuz*" -print 2>/dev/null)"
    if [ -n "$krnfile" ]; then
      krnfile="$(basename $krnfile)"
      sys_files_dir="$i"
      irdfile="$(find $stage1_iso_TMP/$i/ -maxdepth 1 -name "initrd*" -print)"
      irdfile="$(basename $irdfile)"
      break
    fi
  done
  BOOT_ITEM_DIR=$ISOSYSLNX_TMP/$sys_files_dir
  [ ! -d $BOOT_ITEM_DIR ] && mkdir $BOOT_ITEM_DIR

  if [ -z "$sys_files_dir" ]; then
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo "No system files from template live iso are found!"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo "$msg_program_stop"
    exit 1
  fi
  
  if [ -z "$krnfile" -o -z "$irdfile" ]; then
     [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
     echo "Kernel and initrd files NOT found in path $stage1_iso_TMP/$sys_files_dir/!"
     echo "$msg_program_stop"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     exit 1
  fi

  if [ "$output_mode" = "cdwriter" -a type wodim &>/dev/null ]; then
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo "Program wodim is not aviailable! You have to install it."
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo "$msg_program_stop"
    exit 1
  fi
  # Now we can insert the boot menu of syslinux/isolinux
  mkdir -p $ISOSYSLNX_TMP/syslinux $ISOSYSLNX_TMP/EFI/boot/
  # create isolinux menu
  # isolinux should be rw, so we have to copy it, and exclude the one in iso image.
  # We have to overwrite isolinux.bin since vesamenu.c32 should be same version with that.
  # Jan/19/2014 For both syslinux and isolinux (unified in one dir)
  # For syslinux
  cp -af $isolinux_file $pxelinux_simple_vesamenu $pxelinux_simple_menu $pxelinux_memdisk_file $pxelinux_bg_img $pxelinux_chain_file $ISOSYSLNX_TMP/syslinux/
  # For Syslinux 5, new .c32 are required: ldlinux.c32, libcom32.c32, libutil.c32
  for i in $sys_pxelinux_v5p_required_c32; do
    if [ -e "$pxelinux_binsrc_dir/$i" ]; then
      # syslinux <= 5 
      cp -af $pxelinux_binsrc_dir/$i $ISOSYSLNX_TMP/syslinux/
    elif [ -e "$pxelinux_binsrc_dir/bios/$i" ]; then
      # syslinux >= 6, different path
      cp -af $pxelinux_binsrc_dir/bios/$i $ISOSYSLNX_TMP/syslinux/
    fi
  done
  # 2. For EFI machine
  # Copy the EFI boot files
  if [ "$live_efi_boot_loader" = "grub" ]; then
    if [ -e "$stage1_iso_TMP/EFI/boot/bootia32.efi" -a -e "$stage1_iso_TMP/EFI/boot/bootx64.efi" ]; then
      # The EFI/boot/{bootia32.efi,boox64.efi} are copied by the above rsync command from $stage1_iso_TMP
      cp -af $stage1_iso_TMP/EFI $ISOSYSLNX_TMP
      cp -af $pxelinux_bg_img $ISOSYSLNX_TMP/EFI/boot/
    fi
  elif [ "$live_efi_boot_loader" = "syslinux" ]; then
    # Those files are prepared in /usr/share/drbl/pkg/syslinux/efi64/ by drbl-prepare-pxelinux
    cp -af $pxelinux_binsrc_dir/efi64/syslinux.efi $ISOSYSLNX_TMP/EFI/boot/bootx64.efi 
    cp -af $pxelinux_binsrc_dir/efi64/ldlinux.e64 $ISOSYSLNX_TMP/EFI/boot/
    cp -af $pxelinux_binsrc_dir/efi64/*.c32 $ISOSYSLNX_TMP/EFI/boot/
    cp -af $pxelinux_bg_img $ISOSYSLNX_TMP/EFI/boot/
  fi

  # etherboot_zlilo="$($query_pkglist_cmd drbl-etherboot 2>/dev/null | grep -E "eb-.*-etherboot-pci.zlilo$" || true)"
  # if [ -n "$etherboot_zlilo" ]; then
  #   # We have to force it name as etherboot.zdsk, since isolinux only uses the "plain" ISO 9660 filenames, i.e. it does not support Rock Ridge or Joliet filenames.
  #   # ref: http://syslinux.zytor.com/archives/2006-October/007440.html
  #   # "-" will be regards as "_" if you want to use "-" for isolinux.
  #   # In syslinux on vfat, etherboot.zlilo is too long, make it ever shorter as eb.zli
  #   cp -af $etherboot_zlilo $BOOT_ITEM_DIR/eb.zli
  # fi
  # Same reason, we have to use different name in isolinux
  # gPXE is deprecated, we will use iPXE. We keep this gpxe part for ref only.
  gpxe_lkn="$($query_pkglist_cmd gpxe 2>/dev/null | grep -E "gpxe.lkrn$" || true)"
  if [ -n "$gpxe_lkn" ]; then
    # This is run in DRBL server
    cp -af $gpxe_lkn $BOOT_ITEM_DIR/gpxe.lkn
  fi
  # Same reason, we have to use different name in isolinux
  # For ipxe from Debian, there are 2 "ipxe.lkrn", and one of them is symbolic file:
  # $ dpkg -c ipxe_1.0.0+git-20150424.a25a16d-1_all.deb | grep ipxe.lkrn
  # -rw-r--r-- root/root    279677 2015-04-30 03:04 ./boot/ipxe.lkrn
  # lrwxrwxrwx root/root         0 2015-04-30 03:04 ./usr/lib/ipxe/ipxe.lkrn -> /boot/ipxe.lkrn
  # Therefore we force to use "-L" option in cp command
  ipxe_lkn="$(LC_ALL=C $query_pkglist_cmd ipxe 2>/dev/null | grep -Ew "ipxe.lkrn$" | tail -n 1)"
  if [ -n "$ipxe_lkn" ]; then
    # This is run in DRBL server
    cp -afL $ipxe_lkn $BOOT_ITEM_DIR/ipxe.lkn
  fi
  # For ipxe from Debian, there are 2 "ipxe.efi", and one of them is symbolic file:
  # $ dpkg -c ipxe_1.0.0+git-20150424.a25a16d-1_all.deb | grep ipxe.efi
  # -rw-r--r-- root/root    754752 2015-04-30 03:04 ./boot/ipxe.efi
  # lrwxrwxrwx root/root         0 2015-04-30 03:04 ./usr/lib/ipxe/ipxe.efi -> /boot/ipxe.efi
  # Therefore we force to use "-L" option in cp command
  ipxe_efi="$(LC_ALL=C $query_pkglist_cmd ipxe 2>/dev/null | grep -Ew "ipxe.efi$" | tail -n 1)"
  if [ -n "$ipxe_efi" ]; then
    # This is run in DRBL server
    cp -afL $ipxe_efi $BOOT_ITEM_DIR/ipxe.efi
  fi
  # Same reason, we have to use different name in isolinux
  [ -e "$fdos_img_src" ] && cp -af $fdos_img_src $BOOT_ITEM_DIR/freedos.img
  [ -e "$memtest86_file" ] && cp -af $memtest86_file $BOOT_ITEM_DIR/memtest

  # Put the tag
  # The VER_TAG is like drbl-live-xfce-20070315
  VER_TAG="$(echo $real_target_iso | sed -e "s/.iso$//g")"
  create_version_tag_in_live $ISOSYSLNX_TMP/DRBL-Live-Version "$VER_TAG"
  # Copy another one in the live dir. It will be used for toram=live mode.
  cp -a $ISOSYSLNX_TMP/DRBL-Live-Version $ISOSYSLNX_TMP/$sys_files_dir/

  # Excluding list for mkisofs
  # We will create it like this:
  # -x $stage1_iso_TMP/isolinux -x $stage1_iso_TMP/md5sum.txt -x $stage1_iso_TMP/casper/memtest 
  mkiso_exclude_list="isolinux syslinux EFI .disk md5sum.txt doc utils "
  for i in $live_sys_files_dir_list; do
    if [ -e "$stage1_iso_TMP/$i/memtest" ]; then
      mkiso_exclude_list="$mkiso_exclude_list $i/memtest"
      break
    fi
  done
  mkiso_exclude_opt=""
  for i in $mkiso_exclude_list; do
    mkiso_exclude_opt="$mkiso_exclude_opt -x $stage1_iso_TMP/$i"
  done

  # Find the boot param $boot_param
  if [ "$template_mode" = "from-booting-live-media" ]; then
    # From boot media (clonezilla live), DEBIAN_ISO_TMP is LIVE_MEDIA
    # Jan/19/2014 We have unified syslinux and isolinux to one dir "syslinux"
    get_live_boot_param $stage1_iso_TMP/syslinux
  else
    # From iso file (debian-live-for-ocs.iso)
    get_live_boot_param $stage1_iso_TMP/isolinux
  fi
  # generate the menu
  # For isolinux
  # The reason to use "--toram-mode live" is to make "toram" boot menu for live-boot to copy
  # the files from live direcotry, i.e. not only filesystem.squashfs, but also vmlinuz and
  # initrd.img so that drbl-sl can find the vmlinuz and initrd.img to put in
  # /tftpboot/nbi_img/ for drbl clients.
  ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for BIOS machine" isolinux $ISOSYSLNX_TMP/syslinux/
  # For syslinux
  ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for BIOS machine" syslinux $ISOSYSLNX_TMP/syslinux/
  # For EFI, grub2 efi or syslinux efi
  if [ "$live_efi_boot_loader" = "grub" ]; then
    if [ -e "$ISOSYSLNX_TMP/EFI/boot/bootia32.efi" -a -e "$ISOSYSLNX_TMP/EFI/boot/bootx64.efi" ]; then
      ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for EFI machine" grub2-efi $ISOSYSLNX_TMP/EFI/boot/
    fi
  elif [ "$live_efi_boot_loader" = "syslinux" ]; then
    ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for EFI machine" syslinux $ISOSYSLNX_TMP/EFI/boot/
  fi

  echo "Preparing syslinux.exe, syslinux, makeboot.bat and makeboot.sh in dir utils... "
  if [ -z "$isolinux_ver" ]; then
    isolinux_ver="$(LC_ALL=C strings $ISOSYSLNX_TMP/syslinux/isolinux.bin | grep "^ISOLINUX" | awk -F" " '{print $2}')"
  fi
  put_syslinux_makeboot_for_usb_flash $ISOSYSLNX_TMP/ $isolinux_ver
  
  # $sys_files_dir maybe /casper, /live or /isolinux. If it is isolinux, we can not list them twice otherwise mkisofs will go wrong.
  if [ "$sys_files_dir" != "isolinux" ]; then
    sys_files_dir_graft_point="/syslinux/=$ISOSYSLNX_TMP/syslinux/ /$sys_files_dir/=$ISOSYSLNX_TMP/$sys_files_dir/"
  else
    sys_files_dir_graft_point="/syslinux/=$ISOSYSLNX_TMP/syslinux/" 
  fi
  #
  if [ -d "$ISOSYSLNX_TMP/EFI" ]; then
    sys_files_dir_graft_point="$sys_files_dir_graft_point /EFI/=$ISOSYSLNX_TMP/EFI"
  fi

  # Remove the existing iso
  [ -e "$real_target_iso" ] && rm -f $real_target_iso

  # Build the EFI boot image. This is especially for iso file. Not for USB stick.
  efi_img_opt=""
  if [ "$enabled_EFI" = "true" ]; then
    # The following codes are referred from Fedora 
    EFI_BOOTIMG_TMP="$(mktemp -d /tmp/efi-boot.XXXXXX)"
    EFI_BOOTTREE="$stage1_iso_TMP/EFI"
    EFI_IMGTREE="$ISOSYSLNX_TMP/EFI/images"
    EFI_IMG="$EFI_IMGTREE/efiboot.img"
    mkdir -p $EFI_IMGTREE
    rm -rf $ISOSYSLNX_TMP/.disk
    rm -f $EFI_IMG
    
    BOOTDISKSIZE="$(LC_ALL=C du -kcs $EFI_BOOTTREE | tail -n1 | awk '{print $1}')"
    BOOTDISKSIZE="$(LC_ALL=C echo "scale=0; $BOOTDISKSIZE * 1.03 / 1" | bc -l)"
    echo "The size of the $EFI_IMG is $BOOTDISKSIZE"
    mkdosfs -n DRBL-EFI -C $EFI_IMG $BOOTDISKSIZE >/dev/null
    mount -o loop,shortname=winnt,umask=0077 -t vfat $EFI_IMG $EFI_BOOTIMG_TMP
    mkdir -p $EFI_BOOTIMG_TMP/EFI/

    if [ "$live_efi_boot_loader" = "grub" ]; then
      # In this case, bootx64.efi is in $EFI_BOOTTREE/, but we should exclude the existing $EFI_BOOTTREE/images/efiboot.img
      # However, when mkdosfs we do not exclude $EFI_BOOTTREE/images/efiboot.img, so the size might be counted. It's better to put efiboot.img not in /EFI/ in the future.
      rsync -a --exclude images/ $EFI_BOOTTREE/* $EFI_BOOTIMG_TMP/EFI/
    elif [ "$live_efi_boot_loader" = "syslinux" ]; then
      # In this case, bootx64.efi is copied in $ISOSYSLNX_TMP/EFI/, we should do something similar with ocs-gen-grub2-efi-bldr
      rsync -a --exclude images/ $ISOSYSLNX_TMP/EFI/* $EFI_BOOTIMG_TMP/EFI/
      # TODO similar to ocs-gen-grub2-efi-bldr, create a syslinux.cfg to include /syslinux/syslinux.cfg.
    fi
    umount $EFI_BOOTIMG_TMP
    if [ -d "$EFI_BOOTIMG_TMP" -a -n \
    	"$(echo $EFI_BOOTIMG_TMP | grep -e "efi-boot")" ]; then
      rm -rf $EFI_BOOTIMG_TMP
    fi
    
    # Create an info file for grub2 to autodetect the cd root
    # Ref: http://www.sysresccd.org/forums/viewtopic.php?f=5&t=4410
    mkdir $ISOSYSLNX_TMP/.disk
    echo -n "[DRBL]" > $ISOSYSLNX_TMP/.disk/info
    
    efi_img_opt="-eltorito-alt-boot -efi-boot EFI/images/efiboot.img -no-emul-boot"
    # For Ubuntu uEFI secure boot signed grubx64.efi, it will search /boot/grub/grub.cfg instead of what we have (/EFI/boot/grub.cfg). Although we do not use Ubuntu as the underlaying OS, we still keep this for the future just in case.
    mkdir -p $ISOSYSLNX_TMP/boot/grub/
    cat <<-EFI_END > $ISOSYSLNX_TMP/boot/grub/grub.cfg
# This file is for compatibility to Ubuntu Linux's uEFI secure boot. 
# The real config file for grub is /EFI/boot/grub.cfg.
configfile /EFI/boot/grub.cfg
EFI_END
    efi_img_graft_opt="/.disk/=$ISOSYSLNX_TMP/.disk /boot/=$ISOSYSLNX_TMP/boot/ "
  fi

  # Prepare the sort file for genisoimage.
  gen_iso_sort_file $ISOSYSLNX_TMP/syslinux/iso_sort.txt

  # Create the iso file
  genisoimage \
   -A "DRBL Live CD" \
   -V "DRBL-live" \
   -publisher "DRBL/Clonezilla http://drbl.org http://clonezilla.org" \
   -f -r -hide-rr-moved -hide-joliet-trans-tbl -J -l \
   -b syslinux/isolinux.bin -c syslinux/boot.cat \
   -no-emul-boot -boot-load-size 4 -boot-info-table \
   -sort $ISOSYSLNX_TMP/syslinux/iso_sort.txt \
   $efi_img_opt \
   $mkiso_exclude_opt \
   -graft-points \
   $sys_files_dir_graft_point \
   $efi_img_graft_opt \
   /GPL=$DRBL_SCRIPT_PATH/doc/GPL \
   /DRBL-Live-Version=$ISOSYSLNX_TMP/DRBL-Live-Version \
   /utils=$ISOSYSLNX_TMP/utils \
   $stage1_iso_TMP \
   > $real_target_iso
  RC_ISO=$?
  if [ "$RC_ISO" -eq 0 ]; then
    [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
    echo "The $real_target_iso is created successfully!"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  else
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo "The $real_target_iso is NOT created!"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  fi
} # end of create_drbl_live_iso
#
create_drbl_live_zip() {
  # create temp dir for usb flash drive
  echo "$msg_delimiter_star_line"
  echo "Creating DRBL server zip file..."
  echo "$msg_delimiter_star_line"
  #
  # Possible kernel/initrd paths are /casper (created by casper) or /live (created by live-initramfs)
  # Find the kernel and initrd in $stage1_iso_TMP/casper or $stage1_iso_TMP/live
  # Ex: $stage1_iso_TMP/casper/vmlinuz1, /$stage1_iso_TMP/casper/initrd1.img
  # $live_sys_files_dir_list is from drbl-ocs.conf.
  # Possible kernel/initrd paths are /casper (created by casper) or /live (created by live-initramfs)
  sys_files_dir=""
  for i in $live_sys_files_dir_list; do
    krnfile="$(find $stage1_iso_TMP/$i/ -maxdepth 1 -name "vmlinuz*" -print 2>/dev/null)"
    if [ -n "$krnfile" ]; then
      krnfile="$(basename $krnfile)"
      sys_files_dir="$i"
      irdfile="$(find $stage1_iso_TMP/$i/ -maxdepth 1 -name "initrd*" -print)"
      irdfile="$(basename $irdfile)"
      break
    fi
  done

  if [ -z "$sys_files_dir" ]; then
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo "No system files from template live iso are found!"
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    echo "$msg_program_stop"
    exit 1
  fi
  
  if [ -z "$krnfile" -o -z "$irdfile" ]; then
     [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
     echo "Kernel and initrd files NOT found in path $stage1_iso_TMP/$sys_files_dir/!"
     echo "$msg_program_stop"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     exit 1
  fi

  WD="$(pwd)"
  USB_TMP="$(mktemp -d /tmp/ocs-usb-dev.XXXXXX)"
  mkdir -p $USB_TMP/$sys_files_dir
  mkdir -p $USB_TMP/syslinux/ $USB_TMP/EFI/boot/
  echo "Copying files to temp working directory... This might take some time..."
  rsync -av --exclude isolinux --exclude md5sum.txt --exclude doc $stage1_iso_TMP/.  $USB_TMP/
  cp -af $DRBL_SCRIPT_PATH/doc/GPL $USB_TMP/
  # For syslinux
  cp -af $isolinux_file $pxelinux_simple_vesamenu $pxelinux_simple_menu $pxelinux_memdisk_file $pxelinux_bg_img $pxelinux_chain_file $USB_TMP/syslinux/
  # For Syslinux 5, new .c32 are required: ldlinux.c32, libcom32.c32, libutil.c32
  for i in $sys_pxelinux_v5p_required_c32; do
    if [ -e "$pxelinux_binsrc_dir/$i" ]; then
      # syslinux <= 5 
      cp -af $pxelinux_binsrc_dir/$i $USB_TMP/syslinux/
    elif [ -e "$pxelinux_binsrc_dir/bios/$i" ]; then
      # syslinux >= 6, different path
      cp -af $pxelinux_binsrc_dir/bios/$i $USB_TMP/syslinux/
    fi
  done
  # 2. For EFI machine
  # Copy the EFI boot files
  if [ "$live_efi_boot_loader" = "grub" ]; then
    # The EFI/boot/{bootia32.efi,boox64.efi} are copied by the above rsync command from $stage1_iso_TMP
    if [ -d "$USB_TMP/EFI/boot/" ]; then
      cp -af $pxelinux_bg_img $USB_TMP/EFI/boot/
    fi
  elif [ "$live_efi_boot_loader" = "syslinux" ]; then
     # Those files are prepared in /usr/share/drbl/pkg/syslinux/efi64/ by drbl-prepare-pxelinux
     cp -af $pxelinux_binsrc_dir/efi64/syslinux.efi $USB_TMP/EFI/boot/bootx64.efi 
     cp -af $pxelinux_binsrc_dir/efi64/ldlinux.e64 $USB_TMP/EFI/boot/
     cp -af $pxelinux_binsrc_dir/efi64/*.c32 $USB_TMP/EFI/boot/
     cp -af $pxelinux_bg_img $USB_TMP/EFI/boot/
  fi
  # $USB_TMP/EFI and its sub dirs might be not in the mode of 755 since they are copied from the files from iso. We chmod to 755 so that it's easier to remove them by "rm -rf" when it's not used anymore.
  # This especially for zip file, not iso file, because iso file won't only mount it, not unzip it.
  chmod 755 $USB_TMP/EFI
  find $USB_TMP/EFI -type d -exec chmod 755 {} \;

  if [ "$enabled_EFI" = "true" ]; then
    # Build the EFI boot image. This is especially for iso file. Not for USB stick. However, here we still prepare the file so that later it's easier to use genisoimage to create the EFI-enabled iso.
    # The following codes are referred from Fedora 
    EFI_BOOTIMG_TMP="$(mktemp -d /tmp/efi-boot.XXXXXX)"
    EFI_BOOTTREE="$stage1_iso_TMP/EFI"
    EFI_IMGTREE="$USB_TMP/EFI/images"
    EFI_IMG="$EFI_IMGTREE/efiboot.img"
    mkdir -p $EFI_IMGTREE
    rm -rf $USB_TMP/.disk
    rm -f $EFI_IMG
    
    BOOTDISKSIZE="$(LC_ALL=C du -kcs $EFI_BOOTTREE | tail -n1 | awk '{print $1}')"
    BOOTDISKSIZE="$(LC_ALL=C expr $BOOTDISKSIZE + 100)"
    echo "The size of the $EFI_IMG is $BOOTDISKSIZE"
    mkdosfs -n DRBL-EFI -C $EFI_IMG $BOOTDISKSIZE >/dev/null
    mount -o loop,shortname=winnt,umask=0077 -t vfat $EFI_IMG $EFI_BOOTIMG_TMP
    mkdir -p $EFI_BOOTIMG_TMP/EFI/

    if [ "$live_efi_boot_loader" = "grub" ]; then
      # In this case, bootx64.efi is in $EFI_BOOTTREE/, but we should exclude the existing $EFI_BOOTTREE/images/efiboot.img
      # However, when mkdosfs we do not exclude $EFI_BOOTTREE/images/efiboot.img, so the size might be counted. It's better to put efiboot.img not in /EFI/ in the future.
      rsync -a --exclude images/ $EFI_BOOTTREE/* $EFI_BOOTIMG_TMP/EFI/
    elif [ "$live_efi_boot_loader" = "syslinux" ]; then
      # In this case, bootx64.efi is copied in $USB_TMP/EFI/, we should do something similar with ocs-gen-grub2-efi-bldr
      rsync -a --exclude images/ $USB_TMP/EFI/* $EFI_BOOTIMG_TMP/EFI/
      # TODO similar to ocs-gen-grub2-efi-bldr, create a syslinux.cfg to include /syslinux/syslinux.cfg.
    fi
    umount $EFI_BOOTIMG_TMP
    if [ -d "$EFI_BOOTIMG_TMP" -a -n \
    	"$(echo $EFI_BOOTIMG_TMP | grep -e "efi-boot")" ]; then
      rm -rf $EFI_BOOTIMG_TMP
    fi
    
    # Create an info file for grub2 to autodetect the cd root
    # Ref: http://www.sysresccd.org/forums/viewtopic.php?f=5&t=4410
    mkdir $USB_TMP/.disk
    echo -n "[DRBL]" > $USB_TMP/.disk/info
  
    # For Ubuntu uEFI secure boot signed grubx64.efi, it will search /boot/grub/grub.cfg instead of what we have (/EFI/boot/grub.cfg). Although we do not use Ubuntu as the underlaying OS, we still keep this for the future just in case.
    mkdir -p $USB_TMP/boot/grub/
    cat <<-EFI_END > $USB_TMP/boot/grub/grub.cfg
# This file is for compatibility to Ubuntu Linux's uEFI secure boot. 
# The real config file for grub is /EFI/boot/grub.cfg.
configfile /EFI/boot/grub.cfg
EFI_END
  fi

  # Prepare the sort file for genisoimage. Although we do not use genisoimage here, however, we'd like the file created by ocs-live-dev is the same with that of ocs-iso. So it's easier to convert zip file to iso file.
  # Therefore we still put the file iso_sort.txt here.
  gen_iso_sort_file $USB_TMP/syslinux/iso_sort.txt

  # ref: http://syslinux.zytor.com/archives/2006-October/007440.html
  # "-" will be regards as "_" if you want to use "-" for isolinux.
  # In syslinux on vfat, etherboot.zlilo is too long, make it ever shorter as eb.zli
  # etherboot_zlilo="$($query_pkglist_cmd drbl-etherboot | grep -E "eb-.*-etherboot-pci.zlilo$" || true)"
  # if [ -n "$etherboot_zlilo" ]; then
  #   # we have to force it name as etherboot.zdsk, since isolinux only uses the "plain" ISO 9660 filenames, i.e. it does not support Rock Ridge or Joliet filenames.
  #   # ref: http://syslinux.zytor.com/archives/2006-October/007440.html
  #   # "-" will be regards as "_" if you want to use "-" for isolinux.
  #   # In syslinux on vfat, etherboot.zlilo is too long, make it ever shorter as eb.zli
  #   cp -af $etherboot_zlilo $USB_TMP/$sys_files_dir/eb.zli
  # fi
  [ -e "$fdos_img_src" ] && cp -af $fdos_img_src $USB_TMP/$sys_files_dir/freedos.img
  [ -e "$memtest86_file" ] && cp -af $memtest86_file $USB_TMP/$sys_files_dir/memtest
  cp -af $stage1_iso_TMP/$sys_files_dir/{$krnfile,$irdfile} $USB_TMP/$sys_files_dir/
  # Put the tag
  # The VER_TAG is like drbl-live-xfce-20070315
  VER_TAG="$(echo $real_target_zip | sed -e "s/.zip$//g")"
  create_version_tag_in_live $USB_TMP/DRBL-Live-Version "$VER_TAG" 
  # Copy another one in the live dir. It will be used for toram=live mode.
  cp -a $USB_TMP/DRBL-Live-Version $USB_TMP/$sys_files_dir/

  # Find the boot param $boot_param
  if [ "$template_mode" = "from-booting-live-media" ]; then
    # From boot media (clonezilla live), DEBIAN_ISO_TMP is LIVE_MEDIA
    # Jan/19/2014 We have unified syslinux and isolinux to one dir "syslinux"
    get_live_boot_param $stage1_iso_TMP/syslinux
  else
    # From iso file (debian-live-for-ocs.iso)
    get_live_boot_param $stage1_iso_TMP/isolinux
  fi
  # generate the menu
  # For syslinux
  ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for BIOS machine" syslinux $USB_TMP/syslinux/
  # For isolinux
  ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for BIOS machine" isolinux $USB_TMP/syslinux/
  # For EFI, grub2 efi or syslinux efi
  if [ "$live_efi_boot_loader" = "grub" ]; then
    if [ -e "$USB_TMP/EFI/boot/bootia32.efi" -a -e "$USB_TMP/EFI/boot/bootx64.efi" ]; then
      ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for EFI machine" grub2-efi $USB_TMP/EFI/boot/
    fi
  elif [ "$live_efi_boot_loader" = "syslinux" ]; then
    ocs-live-boot-menu -s -vb -l $lang_answer --title "DRBL Live" --toram-mode live -f 785 -n "$version_no" -k /$sys_files_dir/$krnfile -i /$sys_files_dir/$irdfile -m $pxelinux_bg_img --boot-param "$boot_param $live_extra_boot_param" -r "* Boot menu for EFI machine" syslinux $USB_TMP/EFI/boot/
  fi

  echo "Preparing syslinux.exe, syslinux, makeboot.bat and makeboot.sh in dir utils... "
  # Since we can not judge the version from any files in $USB_TMP/syslinux, we use $USB_TMP/isolinux/isolinux.bin.
  if [ -z "$isolinux_ver" ]; then
    isolinux_ver="$(LC_ALL=C strings $USB_TMP/syslinux/isolinux.bin | grep "^ISOLINUX" | awk -F" " '{print $2}')"
  fi
  put_syslinux_makeboot_for_usb_flash $USB_TMP $isolinux_ver
  # just store it. since big files, like squash flie and opt_drbl.tgz are compressed, it's not necessary to compress it again.
  [ -e "$WD/$real_target_zip" ] && rm -f $WD/$real_target_zip
  # Before packing it, make sure all the mode is writable
  chmod -R u+w $USB_TMP
  (cd $USB_TMP; zip -0 -r $WD/$real_target_zip .)
  echo "The created release file is $real_target_zip. You can extract all the files into your pendrive, and run makeboot.bat from pendrive on MS windows."
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo "Warning: DO NOT RUN makeboot.bat from your local hard drive!! It is intended to be run from your USB device."
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  
} # end of create_drbl_live_zip

# default settings
extra_pkgs=""
meta_pkgs=""
rm_tmp_iso="no"
use_existing_stage1_iso="no"
TARGET_MEDIA_FILE_DEF="both"
# Parse command-line options
while [ $# -gt 0 ]; do
  case "$1" in
    -l|--language)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              specified_lang="$1"
              shift
            fi
	    [ -z "$specified_lang" ] && USAGE && exit 1
            ;;
    -a|--initsystem)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              live_initsystem="$1"
              shift
            fi
	    [ -z "$live_initsystem" ] && USAGE && exit 1
            ;;
    -b|--branch)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              drbl_branch="$1"
              shift
            fi
	    [ -z "$drbl_branch" ] && USAGE && exit 1
            ;;
    -bt|--bootstrap)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              bootstrap="$1"
              shift
            fi
	    [ -z "$bootstrap" ] && USAGE && exit 1
            ;;
    -c|--categories)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              categories="$1"
              shift
            fi
	    [ -z "$categories" ] && USAGE && exit 1
            ;;
    -d|--debian-dist)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              debian_dist="$1"
              shift
            fi
	    [ -z "$debian_dist" ] && USAGE && exit 1
            ;;
    -i|--assign-version-no)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              version_no="$1"
              shift
            fi
	    [ -z "$version_no" ] && USAGE && exit 1
            ;;
    -k|--package)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              extra_pkgs="$1"
              shift
            fi
	    [ -z "$extra_pkgs" ] && USAGE && exit 1
            ;;
    -n|--live-kernel-pkg)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              live_kernel_ver="$1"
              shift
            fi
	    [ -z "$live_kernel_ver" ] && USAGE && exit 1
            ;;
    -e|--drbl-live-branch)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              drbl_live_branch="$1"
              shift
            fi
	    [ -z "$drbl_live_branch" ] && USAGE && exit 1
            ;;
    -p|--metapackages)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              meta_pkgs="$meta_pkgs $1"
              shift
            fi
	    [ -z "$meta_pkgs" ] && USAGE && exit 1
            ;;
    -f|--arch-flavor)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              cpu_flavor="$1"
              shift
            fi
	    [ -z "$cpu_flavor" ] && USAGE && exit 1
            ;;
    -g|--drbl-repo-url)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              DRBL_REPOSITORY_URL="$1"
              shift
            fi
	    [ -z "$DRBL_REPOSITORY_URL" ] && USAGE && exit 1
            ;;
    -m|--mirror-url)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              mirror_url="$1"
              shift
            fi
	    [ -z "$mirror_url" ] && USAGE && exit 1
            ;;
    -o|--create-source-tarball)
	    gen_source_tarball="yes"
            shift ;;
    -s|--mirror-security-url)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              mirror_security_url="$1"
              shift
            fi
	    [ -z "$mirror_security_url" ] && USAGE && exit 1
            ;;
    -t|--target-media-file)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              target_media_file="$1"
              shift
            fi
	    [ -z "$target_media_file" ] && USAGE && exit 1
            ;;
    -r|--rm-tmp-iso)
	    rm_tmp_iso="yes"
            shift ;;
    -u|--use-existing-tmp-iso)
            use_existing_stage1_iso="yes"
            shift ;;
    -v|--verbose)
	    verbose="on"
            shift ;;
    -x|--extra-boot-param)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              live_extra_boot_param="$1"
              shift
            fi
	    [ -z "$live_extra_boot_param" ] && USAGE && exit 1
            ;;
    -y|--syslinux-ver)
            shift
            if [ -z "$(echo $1 |grep ^-.)" ]; then
              # skip the -xx option, in case 
              isolinux_ver="$1"
              shift
            fi
	    [ -z "$isolinux_ver" ] && USAGE && exit 1
            ;;
    -*)     echo "${0}: ${1}: invalid option" >&2
            USAGE >& 2
            exit 2 ;;
    *)      break ;;
  esac
done

#
if [ "$use_existing_stage1_iso" = "no" ]; then
  # if we use existing stage 1 iso file, then we do not have to check if lb exists. Otherwise we need make-live to create the stage 1 iso file
  if ! type lb &>/dev/null; then
    [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
    echo "This script only works in Debian Etch or later!"
    echo "If you are running Debian Etch or later, use 'apt-get install live-build' to install the live-build (version $lh_ver_required or later), then run $0 again."
    [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
    exit 1
  fi
  create_live_required_debian_based_prompt
fi

# we need zip to create the release file when target_mode is release_file
if ! type zip &>/dev/null; then
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo "Command zip not found!"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo "$msg_program_stop"
  exit 1
fi

ask_and_load_lang_set $specified_lang

[ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
echo "Creating DRBL live..." 
[ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL

rm -rf debian-live/.stage/

# Apply default settings if not assigned
[ -z "$debian_dist" ] && debian_dist="$DEBIAN_DIST_DEF"
[ -z "$categories" ] && categories="$categories_default"
[ -z "$DRBL_REPOSITORY_URL" ] && DRBL_REPOSITORY_URL="$DRBL_REPOSITORY_URL_def"
[ -z "$mirror_url" ] && mirror_url="$debian_mirror_url_def"
[ -z "$mirror_security_url" ] && mirror_security_url="$debian_mirror_security_url_def"
[ -z "$cpu_flavor" ] && cpu_flavor="$cpu_flavor_default"
[ -z "$bootstrap" ] && bootstrap=$bootstrap_default
[ -z "$live_initsystem" ] && live_initsystem=$live_initsystem_def

# Append the extra packages
[ -n "$extra_pkgs" ] && pkgs="$pkgs $extra_pkgs"

echo "The packages to be included in this live CD:"
echo "$msg_delimiter_star_line"
echo "$pkgs"
echo "$msg_delimiter_star_line"
if [ -n "$meta_pkgs" ]; then
  echo "The packages list to be included in this live CD:"
  echo "$msg_delimiter_star_line"
  echo "$meta_pkgs"
  echo "$msg_delimiter_star_line"
fi

#
echo "Using Debian $debian_dist..."
echo "Using Debian repository from: $mirror_url"
echo "Using Debian security repository from: $mirror_security_url"
echo "Using DRBL repository from: $DRBL_REPOSITORY_URL"

#
case "$drbl_branch" in
  t|testing)
     echo "Using DRBL testing branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="testing"
     ;;
  u|unstable)
     echo "Using DRBL unstable branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="unstable"
     ;;
  e|experimental)
     echo "Using DRBL experimental branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="experimental"
     ;;
  *)
     echo "Using DRBL stable branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="stable"
     ;;
esac
case "$drbl_live_branch" in
  t|testing)
     echo "Using DRBL Live testing branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="$LIVE_REPOSITORY_SECTIONS_drbl live-testing"
     ;;
  u|unstable)
     echo "Using DRBL Live unstable branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="$LIVE_REPOSITORY_SECTIONS_drbl live-unstable"
     ;;
  e|experimental)
     echo "Using DRBL Live experimental branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="$LIVE_REPOSITORY_SECTIONS_drbl live-experimental"
     ;;
  *)
     echo "Using DRBL live stable branch..."
     LIVE_REPOSITORY_SECTIONS_drbl="$LIVE_REPOSITORY_SECTIONS_drbl live-stable"
     ;;
esac

if [ -z "$meta_pkgs" ]; then
  nametag="standard"
else
  # choose the first one, and strip space.
  #nametag="$(echo $meta_pkgs | awk -F" " '{print $1}' | sed -e "s/ //g")"
  # strip the spaces in the beginning and end, replace other space with -
  # task-xfce-desktop -> xfce
  nametag="$(LC_ALL=C echo $meta_pkgs | sed -e "s/^ *//g" -e "s/ *$//g" | awk -F"-" '{print $2}')"
fi
  
# if version_no is not assigned, use date (Ex. 20070409)
[ -z "$version_no" ] && version_no="$(date +%Y%m%d)"
stage1_target_iso="drbl-live-${nametag}-stage1-${version_no}.iso"
real_target_iso="drbl-live-${nametag}-${version_no}.iso"
real_target_zip="drbl-live-${nametag}-${version_no}.zip"
target_src_tarball="drbl-live-src-${version_no}.debian.tar"
target_src_tarball_list="drbl-live-src-${version_no}.debian.contents"
target_src_debian_live_tarball="drbl-live-src-${version_no}.debian-live.tar"
target_src_debian_live_tarball_list="drbl-live-src-${version_no}.debian-live.contents"
[ -z "$target_media_file" ] && target_media_file="$TARGET_MEDIA_FILE_DEF"
echo "$msg_delimiter_star_line"

#2011/Dec/03 Since most of GNU/Linux distributions now use grub2, no more force to use grub-legacy, and we have backup plan by putting grub1 deb package in the live system. 
#if [ "$debian_dist" = "squeeze" -o \
#     "$debian_dist" = "wheezy" -o \
#     "$debian_dist" = "sid" ]; then
#  # From around Oct/2009, the dummy package name "grub" is actually grub-pc, therefore we force to use grub-legacy and assume that if grub2 boot loader is used in the restored GNU/Linux, grub2 is available in the restored GNU/Linux so therefore we can use chroot to run it.
#  # pkgs="$(LC_ALL=C echo $pkgs | sed -r -e "s/grub[[:space:]]+/grub-legacy /")"
#  # Since with squeeze or sid, we can use uvesafb to replace vesafb, we need v86d. Check https://bugs.launchpad.net/ubuntu/+source/v86d/+bug/189621 for more details.
#fi
# Adding libc6-i386 for AMD64 arch. This will allow 32-bit program to run on AMD64 arch.
if [ "$cpu_flavor" = "amd64" ]; then
  pkgs="$pkgs libc6-i386"
fi

if [ "$verbose" = "on" ]; then
  pref="bash -x"
  export DEBOOTSTRAP_OPTIONS="$DEBOOTSTRAP_OPTIONS --verbose"
fi

if [ "$use_existing_stage1_iso" = "no" ]; then
  if [ -d "debian-live" ]; then
    echo "Found dir debian-live, clean stale debian-live files..."
    chroot debian-live/chroot umount /dev/pts &>/dev/null || true
    chroot debian-live/chroot umount /proc &>/dev/null || true
    chroot debian-live/chroot umount /sys &>/dev/null || true
    (
      cd debian-live/
      lb clean
    )
  fi
  rm -rf debian-live
  mkdir debian-live
  (
  cd debian-live

  $pref lb config --archive-areas "$categories"
  # It is important to make the url for --parent-mirror-binary is different from that of --parent-mirror-chroot so that in /usr/lib/live/build/chroot_archives the "lb config --cache-packages false" and "lb config --apt-indices false" can work and those /var/cache/apt/{pkgcache.bin,srcpkgcache.bin} and those /var/lib/apt/lists/{*_Packages,*Release*,*_Sources} will not be cached.
  $pref lb config --parent-mirror-bootstrap $mirror_url --parent-mirror-binary $debian_mirror_url_def --parent-mirror-chroot $mirror_url --parent-mirror-chroot-security $mirror_security_url --parent-mirror-binary-security $debian_mirror_security_url_def --parent-mirror-debian-installer $debian_mirror_url_def
  # Since we use Debian Sid normally, disable updates.
  $pref lb config --updates false
  $pref lb config --mirror-bootstrap $mirror_url
  $pref lb config --mirror-debian-installer $mirror_url
  $pref lb config --mirror-chroot $mirror_url --mirror-chroot-security $mirror_security_url

  # Due to this issue: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=830696
  # We have to add gnupg in the base environment
  export DEBOOTSTRAP_OPTIONS="$DEBOOTSTRAP_OPTIONS --include=gnupg"
  # From live-build 3.0~a58-1, no --bootstrap-flavour option.
  #$pref lb config --bootstrap-flavour $debian_type
  if [ -n "$debian_type" ]; then
    $pref lb config --debootstrap-options="${DEBOOTSTRAP_OPTIONS} --variant=$debian_type"
  fi
  # Since we might assign the package version, e.g. live-boot=3.0.1-1.drbl4.
  # If we do not adding "--no-upgrade", then 
  # in /usr/lib/live/build/chroot_live-packages it will run
  # "apt-get install live-boot" then it will be upgraded.
  $pref lb config --apt apt --apt-options "--yes --no-upgrade --allow-downgrades" --apt-recommends false --bootstrap $bootstrap
  # From live-build 3.0~a59-1, no --volatile option.
  #$pref lb config --volatile false
  # Disable the firmware packages automatically inclusion
  $pref lb config --firmware-binary true --firmware-chroot true
  $pref lb config --security false
  $pref lb config --initramfs live-boot
  # Refer to /usr/share/live/build/functions/defaults.sh for the original boot append parameters.
  # Don't be confused. It won't be appended. Therefore we have to put all required ones.
  $pref lb config --bootappend-live "boot=live union=overlay union=overlay config username=user"
  # Enable cache-indices, by doing this, "apt-get upgrade" won't be run in lb chroot_sources after hook since we might assign older package version when building.
  # This is important especially when there is newer live-boot in Sid. E.g. on 2014/Apr/1 live-boot 4.0 alpha is aviailable, but we still want to keep using 3.0.1-1.drbl4. If --cache-indices is set true, live-boot is upgraded, and 4.0 is installed on the system after filesystem.squashfs is created. Then the initrd.img is re-created again, with live-boot 4.x in initrd.img. It will be inconsistent with what we want.
  $pref lb config --cache-indices true
  $pref lb config --cache-packages false
  $pref lb config --apt-indices false
  $pref lb config --apt-source-archives true
  $pref lb config --tasksel none

  if [ "$debian_dist" = "lenny" ]; then
    # Force to use iso instead of iso-hybrid. Since the syslinux in lenny comes without isohybrid program.
    $pref lb config --binary-images iso
  else
    # Enable iso-hybrid for version >= squeeze
    # //NOTE// This is for template iso only, not for DRBL live iso.
    $pref lb config --binary-images iso-hybrid
  fi

  # This decide_live_kernel_related_pkgs_from_debian function will output "kernel_related_pkgs" and "export MKSQUASHFS_OPTIONS"
  decide_live_kernel_related_pkgs_from_debian
  $pref lb config --distribution $debian_dist --parent-distribution $debian_dist
  $pref lb config --linux-packages "$kernel_related_pkgs"

  # We force to use the specific CPU kernel.
  $pref lb config --linux-flavours $cpu_flavor

  # For OS arch, we can build amd64 Debian on i386 Debian or vice versus.
  case "$cpu_flavor" in
    686*|586*|486*) os_arch="i386";;
    amd64) os_arch="amd64";;
  esac
  $pref lb config --architectures $os_arch
  $pref lb config --initsystem $live_initsystem

  # No memtest from debian, we will use the one from drbl since it's newer.
  $pref lb config --memtest none

  $pref lb config --debian-installer false
  $pref lb config --win32-loader false

  # Disable zsync, it might fail due to download files after /etc/resolv.conf is deconfigured.
  $pref lb config --zsync false

  # Create a source tarball or not.
  if [ "$gen_source_tarball" = "yes" ]; then
    $pref lb config --source true
    $pref lb config --source-images tar
    # Since most of the debian packages are compressed (xz or gzip), we just use none, not the default one gzip.
    $pref lb config --compression none
  else
    $pref lb config --source false
  fi

  # Put files to be included in the chroot hook
  mkdir -p config/includes.chroot/live-hook-dir
  for i in $ocs_live_script_dir; do
    cp -pr $i/* config/includes.chroot/live-hook-dir/
  done
  cp -a /etc/drbl/{drbl.conf,drbl-ocs.conf} config/includes.chroot/live-hook-dir

  # Put the mirror url and settings, which we might need.
  cat <<-HOOK_APPEND_END >> config/includes.chroot/live-hook-dir/ocs-live-hook.conf
  # The following settings were added before running hook" >> config/includes.chroot/live-hook-dir/ocs-live-hook.conf
debian_dist="$debian_dist"
mirror_url="$mirror_url"
drbl_ocs_live_ver="drbl-live-${version_no}"
HOOK_APPEND_END

  # Put packages list in config/package-lists/. //NOTE// Do not use file name like drbl-packages.list. Make it like drbl-packages.list.binary (for lb_binary) or drbl-packages.list.chroot (for lb_chroot). Otherwise lb_binary_package-lists will generate deb repository (/pool). 
  # Ref: http://lists.debian.org/debian-live/2012/07/msg00119.html
  echo "$pkgs" > config/package-lists/drbl-packages.list.chroot

  # Put the pkg list, e.g. task-xfce-desktop
  # Ref: http://live.debian.net/manual/stable/html/live-manual.en.html#346
  echo "$meta_pkgs" >> config/package-lists/drbl-packages.list.chroot

  # Put hook file to be run in chroot
  cp $ocs_live_script_dir/${run_hook_script} config/hooks/${run_hook_script}.chroot

  # Put hook file to be run in the binary local hook
  cp $ocs_live_script_dir/$run_binary_hook_script config/hooks/${run_binary_hook_script}.binary
  
  # prepare drbl source list
  # //NOTE// Use drbl-repository.list instead of drbl-repository.list.chroot because 
  # with ".chroot" it means only for chroot and it will be removed from the squashfs.
  cat << AddDRBLRepository > config/archives/drbl-repository.list
deb $DRBL_REPOSITORY_URL drbl $LIVE_REPOSITORY_SECTIONS_drbl
deb-src $DRBL_REPOSITORY_URL drbl $LIVE_REPOSITORY_SECTIONS_drbl
AddDRBLRepository
  
  # prepare drbl key
  LC_ALL=C wget -O config/archives/drbl-gpg.key $DRBL_GPG_KEY_URL
  
  # Disable apt languages and translations when creating DRBL live. This could reduce apt repository issue.
  disable_apt_lang_translation chroot/etc/apt/apt.conf.d/99lang

  # Build it.
  $pref lb build
  )
  lb_ver="$(LC_ALL=C lb --version)"  # e.g. 3.0.5-1
  if [ "$lb_ver" \> 3 ] && [ "$lb_ver" \< 4 ]; then
    # Live build version 3 
    mv -f debian-live/binary*.iso $stage1_target_iso
    if [ "$gen_source_tarball" = "yes" ]; then
      mv -f debian-live/source.debian.tar $target_src_tarball
      mv -f debian-live/source.debian.contents $target_src_tarball_list
      mv -f debian-live/source.debian-live.tar $target_src_debian_live_tarball
      mv -f debian-live/source.debian-live.contents $target_src_debian_live_tarball_list
    fi
  else
    # Live build version 4
    mv -f debian-live/live-image*.iso $stage1_target_iso
    if [ "$gen_source_tarball" = "yes" ]; then
      mv -f debian-live/live-image-source.debian.contents $target_src_tarball_list
      mv -f debian-live/live-image-source.debian.tar $target_src_tarball
      mv -f debian-live/live-image-source.live.contents $target_src_debian_live_tarball_list
      mv -f debian-live/live-image-source.live.tar $target_src_debian_live_tarball
    fi
  fi
else
  echo "Use existing temp iso file: $stage1_target_iso"
fi
# clean the dir debian-live if $stage1_target_iso is already created
if [ -f "$stage1_target_iso" -a -d "debian-live" ]; then
  echo "Removing working dir debian-live in background..."
  # If live cd is not created, we have to force umount these before rm files.
  umount -l debian-live/chroot/dev/pts &>/dev/null || true
  umount -l debian-live/chroot/proc &>/dev/null || true
  umount -l debian-live/chroot/sys &>/dev/null || true
  rm -rf debian-live &
fi
# 
if [ ! -e "$stage1_target_iso" ]; then
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo "$stage1_target_iso does NOT exist!"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo "$msg_program_stop!"
  exit 1
fi

# mount the stage 1 iso file
stage1_iso_TMP="$(mktemp -d /tmp/ocs-iso-tmp.XXXXXX)"
trap "[ -d "$stage1_iso_TMP" ] && umount $stage1_iso_TMP &>/dev/null && clean_tmp_dirs_files" HUP INT QUIT TERM EXIT
ISOSYSLNX_TMP="$(mktemp -d /tmp/isolnx-tmp.XXXXXX)"
mount -o loop $stage1_target_iso $stage1_iso_TMP

# Check if EFI boot could be supported.
if [ ! -e "$stage1_iso_TMP/EFI/boot/bootx64.efi" ]; then
  # We only check bootx64.efi since bootx86.efi is optional.
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo "Warning! /EFI/boot/bootx64.efi was not found in stage1 DRBL live!"
  echo "The generated $target_iso will not support EFI boot!"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  sleep 5
  enabled_EFI="false"
elif [ -n "$(LC_ALL=C genisoimage --help 2>&1 | grep -E -- "-efi-boot")" ]; then
  # Check if genisoimage support -efi-boot option
  enabled_EFI="true"
else
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo "Warning! Setting EFI boot image name is not supported in genisoimage!"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  sleep 5
  enabled_EFI="false"
fi
  
#
case "$target_media_file" in
  cd|CD|iso|ISO)
     create_drbl_live_iso
     ;;
  usb|zip)
     create_drbl_live_zip
     ;;
  b|both|BOTH)
     create_drbl_live_iso
     create_drbl_live_zip
     ;;
esac

# unmount all iso file
umount $stage1_iso_TMP &>/dev/null

# Isohybrid the generated iso file.
# //NOTE// This is for DRBL live iso. It's different from that for template iso.
if [ -e "$real_target_iso" ]; then
  if type isohybrid &>/dev/null; then
    echo -n "Isohybriding $real_target_iso... "
    isohybrid --uefi $real_target_iso
    echo "done!"
  fi
fi

case "$target_media_file" in
  cd|CD|iso|ISO)
     [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
     echo "$msg_burn_drbl_live_img_iso: $real_target_iso"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     ;;
  usb|zip)
     [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
     echo "$msg_burn_drbl_live_img_zip: $real_target_zip"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     ;;
  b|both|BOTH)
     [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
     echo "$msg_burn_drbl_live_img_iso: $real_target_iso"
     echo "$msg_burn_drbl_live_img_zip: $real_target_zip"
     [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
     ;;
esac

# ///NOTE/// This should be the last command otherwise the rest of commands might be skipped due to trap.
# Clean the tmp working directory
echo "Cleaning tmp dirs..."
clean_tmp_dirs_files
